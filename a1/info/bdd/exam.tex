\documentclass[landscape]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage[left=1cm, right=1cm, bottom=1cm, top=1cm]{geometry}
\usepackage{fixltx2e}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{stmaryrd}
\usepackage{bbm}
\usepackage[dvipsnames]{xcolor}
%\usepackage[object=vectorian]{pgfornament}
%\usetikzlibrary{shapes.geometric,calc}
\usepackage{algorithm2e}
\usepackage{multicol}
\newcommand{\sep}{\begin{center}
    \pgfornament[width=0.25\linewidth]{84}
\end{center}}
\newcommand{\edornament}{\begin{center}
    \pgfornament[width=0.25\linewidth]{49}
\end{center}}
\newcommand{\seg}[2]{\llbracket #1, #2 \rrbracket}

\MakeRobust{\overrightarrow}

\newcommand{\vc}[1]{\overrightarrow{#1}}
\newcommand{\A}{\mathscr{A}}
\newcommand{\F}{\mathscr{F}}
\newcommand{\B}{\mathscr{B}}
\newcommand{\C}{\mathscr{C}}
\newcommand{\G}{\mathscr{G}}
\renewcommand{\L}{\mathscr{L}}
\newcommand{\V}{\mathscr{V}}
\newcommand{\T}{\mathscr{T}}
\newcommand{\Q}{\mathscr{Q}}
\renewcommand{\H}{\mathscr{H}}
\renewcommand{\P}{\mathscr{P}}
\newcommand{\Er}{\mathscr{E}}
\newcommand{\parts}{\mathscr{P}}
\newcommand{\ntoi}{{n\rightarrow\infty}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\1}{\mathbbm{1}}
\newcommand{\0}{\mathbbm{0}}
\renewcommand{\phi}{\varphi}

\newtheorem{theo}{Théorème}
\newtheorem{lem}{Lemme}
\newtheorem{prop}{Proposition}
\newtheorem{defi}{Définition}
\newtheorem{fact}{Faits}
\newtheorem{ex}{Exemple}

\begin{document}
\begin{multicols}{2}

    \section{Introduction}

    \begin{defi}[SGBD] Fonctionnalités : indépendance physique/logique, accès aisé
        aux données, optimisation de requêtes, intégrité logique/physique,
        partage de données, normalisation.
    \end{defi}

    \begin{defi}[ACID] Atomicité, Cohérence, Isolation, Durabilité.
    \end{defi}

    \begin{fact}[Faiblesses SGBD classiques] Très grands volumes (> Po), débits
        extrêmes (> kRequêtes/s), mal adapté à certains modèles de données, surcoût
        de ACID.
    \end{fact}

    \begin{defi}[Schéma de relation d'arité $n$]0
        Soient $\L$ les étiquettes, $\V$ les valeurs et $\T\subset\P(\V)$ les types
        des ensembles infinis dénombrables. Un schéma de relation est un $n$-uplet
        $(A_i)_{1\leq i \leq n}\in(\L\times \T)^n$ tel que $A_i\neq A_j$ pour tout
        $1\leq i,j\leq n$.
    \end{defi}

    \begin{defi}[Schéma relationnel] Ensemble de schéma de relations étiquetés.
    \end{defi}

    \begin{defi}[Contraintes d'intégrité] Pour une instance :\begin{itemize}
        \item Clef : attributs d'une relation permettant d'identifier les
            éléments de l'instance.
        \item Clef étrangère : attributs d'une relation permettant d'identifier
            (existence + unicité) les éléments d'une autre relation.
        \item Contrainte Check : condition arbitraire sur les valeurs des attributs
            d'une relation.
    \end{itemize}\end{defi}

    \section{Aspects logiques}

    \begin{defi}[Algèbre relationelle : opérateurs]
        \begin{tabular}{ccll}
            \hline
            Op. & Arité & Description & Condition \\
            \hline
            $R$ & 0 & Nom de relation & $R \in \L$ \\
            $\rho_{A\rightarrow B}$ & 1 & Renommage & $A,B\in\L$ \\
            $\Pi_{A_1,\ldots A_n}$ & 1 & Projection & $A_i\in\L$ \\
            $\sigma_\phi$ & 1 & Sélection & $\phi$ formule \\
            $\times$ & 2 & Produit cartésien & \\
            $\cup$ & 2 & Union & \\
            $\backslash$ & 2 & Différence & \\
            $\bowtie_\phi$ & 2 & Jointure & $\phi$ formule \\
            \hline
        \end{tabular}
    \end{defi}

    \begin{defi}[Requêtes] \begin{itemize}
        \item Requêtes conjonctives : $x_a, x_b \leftarrow R_1(x, x_a), R_2(x', x_b, x''), R_3(x_b, x'')$
        \item Calcul conjonctif : $\{x_a, x_b | \exists x \exists x' \exists x''(R_1(x, x_a)\wedge R_2(x', x_b, x'')\wedge R_3(x_b, x'')) \}$
        \item Algèbre PSJR : projection, sélection, jointure, renommage.
    \end{itemize}\end{defi}

    \begin{theo}[Théorème d'équivalence PSJR]
        Les requêtes conjonctives, le calcul conjonctif et l'algèbre PSJR permettent
        d'exprimer les mêmes requêtes.
    \end{theo}

    \begin{theo}[Théorème d'équivalence PSJRU]
        L'équivalence reste vraie si on ajoute l'union à l'algèbre, le $\vee$ au
        calcul et la possibilité de mettre plusieurs requêtes.
    \end{theo}

    \begin{defi}[Sémantique domaine active]
        On défini le domaine actif d'une instance comme l'ensemble des constantes.
        Cette sémantique de requêtes ne renvoit que des tuples contenant des éléments
        du domaine actif de l'instance.
    \end{defi}

    \begin{theo}[Théorème d'équivalence]
        Algèbre, calcul et datalog (avec $\backslash$, $\forall$, et $\neg$) sont
        équivalents.
    \end{theo}

    \section{Requêtes récursives}

    %TODO faits intensionnels/extensionnels
    \begin{defi}[Datalog]
      Datalog est le langage composé des requêtes conjonctives, auquels ont a
      ajouté la récursion. Chaque règle $r$ d'un programme $P$ peut être vu
      comme une requête conjonctive sur une base de donnée $D$. On le note
      $S(\mathbb{b}) \leftarrow R_1(\mathbb{x}_1),...,R_n(\mathbb{x}_n)$, avec
      $S$ une relation du schémas intensionnel, $R_1,...,R_n$ des relations du
      schéma intensionnel ou extensionnel, $\mathbb{x}_i,\mathbb{y}$ des
      tuples variables ou des constantes, dont les variables de $\mathbb{y}$
      sont présentes dans au moins un $\mathbb{x}_i$
    \end{defi}
    
    \begin{defi}[Datalog : Sémantique de point fixe]
      On définit l'opérateur de conséquence 
      $\Gamma_P(D) := D \bigcup_{r\in P}\{r(D)\}$. On considère la suite $(D_n)$
      définie par $D_0 = D, D_{n+1} = \Gamma_P(D_n)$. La sémantique de $P$ sur
      $D$ est l'ensemble des faits de la relation $But$ dans $D_\infty$, le
      point fixe de la suite.
    \end{defi}

    \begin{defi}[Trellis complet]
      Un trellis complet $L$ est un ensemble muni d'un ordre partiel dans lequel
      tout sous-ensemble admet une borne supérieure et une borne inférieure
    \end{defi}
    
    \begin{theo}[Knaster-Tarski]
      Si $L$ est un trellis complet, et $f : L \rightarrow L$ une application
      croissante sur $L$, alors les points fixes de $f$ forment un treillis complet.
    \end{theo}

    \begin{prop}[Application à datalog]
      L'ensemble des parties d'un ensemble (ordonné par l'inclusion) est un
      treillis complet. Comme $\Gamma_P$ est croissant, en appliquant le
      théorème précédent, il existe un plus petit point fixe, obtenu par
      l'intersection de tout les points fixes.
    \end{prop}

    \begin{defi}[Arbre de preuve]
      On peut définir un arbre de preuve d'un tuple $But(a_1,...,a_n)$. Avec
      $But(a_1,...,a_n)$ la racine de l'arbre, chaque noeud étant
      l'instantiation de la tête d'une règle, et ses enfants les instantiations
      du corps de la règle. Les feuilles sont des faits extentionnels.
    \end{defi}

    \begin{defi}[Datalog non récursif]
      Le graphe d'un programme Datalog est le graphe dont les noeuds sont des
      relations du schémas intensionnel, et dans lequel il existe un noeud
      $(R,S)$ si il existe une règle avec $R$ dans le corps et $S$ dans la tête.
      Un programme Datalog est non récursif si le graphe est acyclique.
    \end{defi}

    \begin{fact}
      Un programme Datalog non récursif à le même pouvoir d'expression que les
      unions de requêtes conjonctives.
    \end{fact}

    \begin{defi}[Logique inflationniste et non-inflationniste]
      Logique non inflationniste (opérateur $:=$) plus expressive, mais logique
      inflationniste (opérateur $+=$) ne peut pas avoir de boucles infinies.
      Dans les deux cas, on utilise le nouvel opérateur, et la boucle ``while no
      change do ... done''
    \end{defi}

    \begin{defi}[construction de point fixes]
      On ajoute au calcul relationnel une construction du plus petit point fixe
      non inflationniste
      $\mu_T[\phi(T)](x_1,...,x_n)$, avec $x_1,...,x_n$ les variables libres de
      $\phi(T)$, et $\phi(T)$ une formule de calcul contenant une nouvelle
      relation $T$. La constrution du plus petit point fixe inflationniste est
      similaire, avec la notation $\mu^+_T$. Ces opérateurs sont équivalents au
      while associés.
    \end{defi}

    \begin{fact}[Applciation à la logique du second ordre]
      L'opérateur de point fixe peut immédiatement se retranscrire en logique du
      second ordre.
    \end{fact}

    \begin{fact}[Opérateur de négation]
      Avec l'opérateur de négation, on est toujours équivalent au calcul avec
      point fixe inflationniste, et à l'algèbre avec while inflationniste
    \end{fact}

    \begin{defi}[Syntaxe en SQL]
      WITH RECURSIVE $T(x_1,...,x_n)$ AS ( 
      SELECT (Cas de base)
      UNION
      SELECT (Cas de récursion)
      )
      SELECT * FROM T\\
      La logique est inflationniste, mais si il y a des créations de variables,
      cela peut rentrer dans une boucle infinie.
    \end{defi}

    \section{Complexité des langages de requête}

    \begin{defi}[Capture] Un langage de requête $\Q$ capture un classe de complexité
        $\C$ si :\begin{itemize}
            \item pour tout $Q\in\Q$, évaluer $Q$ est dans $\C$ en complexité
                en les données.
            \item pour tout $P\in\C$, il existe $Q\in\Q$ dont l'évaluation
                résoud $P$.
        \end{itemize}
    \end{defi}

    \begin{theo}[Classes de complexité]
        \begin{tabular}{r|cc}
            \hline Langage & donnés & combinée \\
            \hline
            $CQ$ & $PTIME$ & $NP$-complet \\
            $FO$ & $AC0\subset PTIME$ & $PSPACE$-complet \\
            $FO+\mu^+$ & $PTIME$-complet & \\
            $FO+\mu$ & $PSPACE$-complet & \\
            \hline
        \end{tabular}
    \end{theo}

    \begin{defi}[$\alpha$-acyclicité]
        Soit $R$ une requête conjonctive. $R$ peut être vue comme un hypergraphe $\H$
        dont les sommets sont les variables et les hyperarêtes les atomes. $R$ est
        $\alpha$-acyclique si $H$ admet un arbre de jointure, ie un arbre vérifiant :
        \begin{itemize}
            \item chaque hyperarête de $\H$ apparait comme étiquette d'un noeud de l'arbre.
            \item pour chaque sommet $x$ de $\H$, l'ensemble des noeuds de l'arbre étiquetés
                par une arêtes incluant $x$ est un sous-arbre connexe.
        \end{itemize}
    \end{defi}

    \begin{theo}[Théorème de Tarjan et Yannakabis]
        L'arbre de jointure d'une requête peut être obtenu en temps linéaire
        s'il existe.
    \end{theo}

    \begin{theo}[Algorithme de Yannakabis]
        % TODO détail de l'algorithme
        Une requête $\alpha$-acyclique s'évalue en temps combiné polynomial.
    \end{theo}

    \begin{theo} $FO+\mu^+$ capture $PTIME$ sur les données avec un ordre total sur
        les éléments du domaine.
        
        $FO+\mu$ capture $PSPACE$ sur les données avec un ordre total sur les éléments
        du domaine.
    \end{theo}

    \section{Contraintes et poursuite}

    \begin{defi}[Dépendance fonctionnelle (FD)]
        Une instance $r$ vérifie $X\rightarrow Y$, noté $x\models X\rightarrow Y$,
        si $\forall t, t'\in r, t[X] = t[X']\implies t[y] = t'[y]$.
    \end{defi}

    \begin{defi}[Dépendance multivaluée (MVD)]
        $r\models X\twoheadrightarrow Y$ si, pour $Z$ les attributs de $R$ hors
        $X\cup Y$, $\forall t, t'\in R, t[X] = t[X'] \implies \exists t''\in r:
        t''[Y] = t[y] \wedge t''[Z] = t'[Z]$
    \end{defi}

    \begin{defi}[Algorithme de poursuite]
        Décide si une dépendance est impliquée par un ensemble de dépendances, en
        partant d'une instance pour une relation avec deux éléments, puis en ajoutant
        des éléments en utilisant les dépendances initiale jusqu'à obtenir une instance
        vérifiant ces dépendances. Si la dépendance finale est vérifiée, alors
        elle est impliquée, sinon l'instance créée est un contre-exemple.
    \end{defi}

    \begin{theo}[Maier]
        La poursuite par des FD et MVD termine toujours après un nombre fini
        d'opérations, et contruit un contre-exemple si et seulement s'il en
        existe un.
    \end{theo}

    \begin{defi}[Dépendances génératrices d'égalités (EGD)]
        $\forall x_1,\ldots x_n, \phi(x_1,\ldots x_n)\implies \psi(x_1,\ldots x_n)$
        avec $\phi$ une CQ et $\psi$ une conjonction d'égalités. Les EGD généralisent
        les FD.
    \end{defi}

    \begin{defi}[Dépendances génératrices de tuples (TGD)]
        $\forall x_1,\ldots x_n, \phi(x_1,\ldots x_n)\implies\exists y_1,\ldots y_m, \psi(x_1,\ldots x_n, y_1, \ldots y_m)$
        avec $\phi$ et $\psi$ des CQ. Les TGD généralisent les MVD et les ID
        (clefs étrangères).
    \end{defi}

    % TODO poursuite générale

    \section{Théorie de la normalisation}
    
    % TODO 3NF et BCNF definitions

    \section{Analyse statique de requêtes}

    \begin{defi}[Inclusion]
        Une requête $q$ est incluse dans une requête $q'$ (noté $q\sqsubseteq q'$)
        si pour toute base de données $D$, $q(D)\subseteq q'(D)$.
    \end{defi}

    \begin{prop}[Équivalence et inclusion]
        $q\equiv q' \iff q\sqsubseteq q'\wedge q'\sqsubseteq q$
    \end{prop}

    \begin{defi}[Homomorphisme]
        Un homomorphisme $\phi$ d'une CQ $q$ dans une CQ $q'$ est une fonction
        des variables de $q$ dans celles de $q'$ telle que pour tout atome
        $R(z_i)$ de $q$, il existe un atome $R(z'_{i'})$ dans $q'$ avec
        $\phi(z_i) = z'_{i'}$.

        Un isomorphisme est un homomorphisme bijectif dont la bijection réciproque
        est un homomorphisme.
    \end{defi}

    \begin{defi}[Instance associée à une requête] Soit $q(x) \leftarrow \exists y:
        R_1(z_1)\wedge\ldots\wedge R_n(z_n)$ une CQ. On peut construire $I_q$
        sont instance associée de domaine actif $\{a_z | z\in x\cup y\}$
        formée des $n$ tuples $R(a_{z_{i1}}, \ldots a_{z_{ik}})$ pour
        $R(z_{i1}, \ldots z_{ik})$ atome de $q$.
    \end{defi}

    \begin{prop} Il existe une homomorphisme de $q(x)$ dans $q'(x')$ ssi
        $(a_{x'_1}, \ldots a_{x'_j})\in q(I_{q'})$.
    \end{prop}

    \begin{theo}[Chandra et Merlin] $q\sqsubseteq q'$ ssi il existe un homomorphisme
        de $q'$ dans $q$.
    \end{theo}

    \begin{prop}[Chandra et Merlin] Soit $q$ une CQ. Il existe une requête $q'$
        équivalente minimale à $q$ obtenue en enlevant des atomes à $q$.

        Soient $q,q'$ deux CQ équivalentes minimales. Il existe un isomorphisme
        de $q$ dans $q'$.
    \end{prop}

    \begin{prop} Les problèmes suivants sont $NP$-complets (en les requêtes)~: $q\sqsubseteq q'$,
        $q \equiv q'$ et la non minimalité de $q$.
    \end{prop}

    \begin{theo}[Trakhtenbrot]
        La satisfiabilité du calcul relationnel (dans le cadre fini) est indécidable.
    \end{theo}

    \begin{theo} L'inclusion et l'équivalence de requêtes du calcul relationnel
        sont indécidables et co-récursivement énumérables.
    \end{theo}

    \section{Vues, provenance, déclencheurs}

    \begin{defi}[Vues] Requêtes auxquelles on donne un nom, s'utilisent comme
        des tables dans d'autres requêtes. Il en existe deux types :\begin{itemize}
            \item Virtuelle : la requête est réévaluée à chaque utilisation.
            \item Matérialisée : la requête est évaluée à sa création et le résultat
                est stocké.
        \end{itemize}
    \end{defi}

    \begin{defi}[Provenance]
        Soit $\chi = \{x_1, \ldots x_n\}$ un ensemble fini d'évènements booléen.
        On nomme une annotation de provenance une fonction booléenne sur $\chi$,
        de type $\nu : (\chi \rightarrow \{\top,\bot\})\rightarrow \{\top,\bot\}$.

        On note $\nu(D)$ la sous instance de D ne contenant que tuples évalués à
        $\top$. La provenance booléenne d'un tuple $t\in q(D)$ pour une requête
        $q$ est :
        \[ \text{prov}_{q,D}(t) : \nu\mapsto\left\{\begin{array}{cl}
            \top & \text{si } t\in q(\nu(D)) \\
            \bot & \text{sinon} \\
        \end{array}\right.\]
    \end{defi}

    \begin{defi}[Semi-anneau commutatif] Un ensemble $(K, \0, \1, \oplus, \otimes)$
        est un semi anneau commutatif si $\oplus$ est associatif, commutatif et
        de neutre $\0_K$, $\otimes$ est associatif, commutatif et de neutre
        $\1_K$, $\otimes$ distribue sur $\oplus$ et $\0$ est annulateur pour
        $\otimes$.
    \end{defi}

    \begin{ex}[Semi-anneau Why]
        $(\P(\P(\chi)), \emptyset, \{\emptyset\}, \cup, \Cup)$, où
        $A\Cup B = \{a\cup b | a\in A, b\in B\}$.
    \end{ex}

    \begin{defi}[Provenance de semi-anneau]
        Soit $(K, \0, \1, \oplus, \otimes)$ un semi anneau. On suppose les annotations
        de provenance dans $K$. On considère une requête $q$ de l'algèbre relationnelle
        positive. On définit la sémantique de la provenance d'un tuple $t\in q(D)$
        récursivement sur $q$: \begin{itemize}
            \item sélection, renommage : on ne change rien.
            \item projection, union : on fusionne avec $\oplus$
            \item produit cartésien ; on fusionne avec $\otimes$
        \end{itemize}
    \end{defi}

    \begin{fact}[Mise à jour de vue] Pour l'insertion, une mise à jour incrémentale
        est possible pour les requêtes de l'algèbre relationnelle positive. Pour
        la suppression, il suffit d'utiliser la provenance booléenne.
    \end{fact}
    
    \begin{defi}[Déclencheurs]
        Fonctions exécutées avant, après ou à la place d'une mise à jour sur une
        table ou une vue.
    \end{defi}

    \section{Évaluation et optimisation des requêtes}

\end{multicols}
\end{document}

